<html>
<head>
    <title>MAP</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        html,
        body,
        #map {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
        }
    </style>
    <script src="https://apis.mappls.com/advancedmaps/api/7e228cc42a410abe8c713c359a3191a1/map_sdk?layer=vector&v=3.0&callback=initMap1" defer async></script>
</head>
<body>
<div id="map"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.4.0/firebase-app.js";
import {
  getFirestore,
  doc,
  getDoc,
  getDocs,
  collection,
} from "https://www.gstatic.com/firebasejs/9.4.0/firebase-firestore.js";

    const firebaseConfig = {
    apiKey: "AIzaSyB1zdPdHi6njKUgiukk-84RVPEzOJFcAxc",
    authDomain: "vit-bus-tracking.firebaseapp.com",
    databaseURL: "https://vit-bus-tracking-default-rtdb.firebaseio.com",
    projectId: "vit-bus-tracking",
    storageBucket: "vit-bus-tracking.appspot.com",
    messagingSenderId: "832936720267",
    appId: "1:832936720267:web:4f170bd4652b5ae10d618e",
    measurementId: "G-5L7PE5VHHX",
  };
  
  
  class LocationData {
    constructor(latitude, longitude, serial) {
      this.latitude = latitude;
      this.longitude = longitude;
      this.serial = serial;
    }
  }
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    async function fetchData() {
  const routes = ["route1", "route2", "route3"];
  let locationArrays = []; // Create an array to store location arrays for each route

  for (const route of routes) {
    const querySnapshot = await getDocs(collection(db, "bus_web", "routes", route));

    let location_array = [];

    querySnapshot.forEach((doc) => {
      location_array.push(
        new LocationData(
          doc.data().lat,
          doc.data().lng,
          doc.data().serial
        )
      );
    });

    location_array.sort(function (a, b) {
      if (a.serial < b.serial) return -1;
      else return 1;
    });

    locationArrays.push(location_array); // Add the location array for the current route to the result array
  }

  return locationArrays; // Return an array of location arrays for all routes
}

fetchData().then((locationArrays) => {
  // Combine location arrays for all routes
  const combinedLocationArray = [].concat(...locationArrays);

  initializeMap(combinedLocationArray);
});


    var map, Marker1, Marker2, Marker3, Marker4, markers = [];

    // Modify the initializeMap function to filter out invalid location data
function initializeMap(location_array) {
    map = new mappls.Map('map', {
        center: [12.840625, 80.153431],
        zoomControl: true,
        location: true,
    });
    map.setZoom(16);

    // Filter out invalid location data (where latitude or longitude is NaN)
    location_array = location_array.filter((location) => {
        return !isNaN(location.latitude) && !isNaN(location.longitude);
    });

    var routeCoordinates = location_array.map(function (location) {
        return { lat: location.latitude, lng: location.longitude };
    });

    var routePolyline = new mappls.Polyline({
        map: map,
        path: routeCoordinates,
        strokeColor: "#FF0000",
        strokeOpacity: 1.0,
        strokeWeight: 2
    });
}

    

</script>


</body>
</html>